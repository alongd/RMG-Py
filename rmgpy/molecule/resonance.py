#!/usr/bin/env python
# encoding: utf-8

################################################################################
#
#   RMG - Reaction Mechanism Generator
#
#   Copyright (c) 2002-2017 Prof. William H. Green (whgreen@mit.edu), 
#   Prof. Richard H. West (r.west@neu.edu) and the RMG Team (rmg_dev@mit.edu)
#
#   Permission is hereby granted, free of charge, to any person obtaining a
#   copy of this software and associated documentation files (the 'Software'),
#   to deal in the Software without restriction, including without limitation
#   the rights to use, copy, modify, merge, publish, distribute, sublicense,
#   and/or sell copies of the Software, and to permit persons to whom the
#   Software is furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in
#   all copies or substantial portions of the Software.
#
#   THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#   DEALINGS IN THE SOFTWARE.
#
################################################################################

"""
This module contains methods for generation of resonance structures of molecules.

The main function to generate all relevant resonance structures for a given
Molecule object is ``generate_resonance_structures``. It calls the necessary
functions for generating each type of resonance structure.

Currently supported resonance types:
- All species:
    - ``generate_ally_delocalization_resonance_structures``: single radical shift with double or triple bond
    - ``generate_lone_pair_radical_resonance_structures``: single radical shift with lone pair
    - ``generate_lone_pair_multiple_bond_resonance_structures``: multiple bond shift with lone pair
    - ``generate_lone_pair_radical_multiple_bond_resonance_structures``: multiple bond and radical shift with lone pair and radical
    - ``generate_N5ddc_N5tc_resonance_structures``: shift between nitrogen with two double bonds and single + triple bond
    - ``generate_birad_multiple_bond_resonance_structures``: two adjacent radicals shift with a multiple bond (unidirectional)
    - ``generate_OS_resonance_structures``: transitions of excited O=O (or its sulfur-containing isoelectronic structures) into the ground [O][O] state (unidirectional)
- Aromatic species only:
    - ``generate_aromatic_resonance_structures``: fully delocalized structure, where all aromatic rings have benzene bonds
    - ``generate_kekule_structure``: generate a single Kekule structure for an aromatic compound (single/double bond form)
    - ``generate_opposite_kekule_structure``: for monocyclic aromatic species, rotate the double bond assignment
    - ``generate_clar_structures``: generate all structures with the maximum number of pi-sextet assignments
"""

import cython
import logging
import itertools

from .graph import Vertex, Edge, Graph, getVertexConnectivityValue
from .molecule import Atom, Bond, Molecule
from .kekulize import kekulize
import rmgpy.molecule.pathfinder as pathfinder
from rmgpy.exceptions import ILPSolutionError, KekulizationError, AtomTypeError

def populate_resonance_algorithms(features=None):
    """
    Generate list of resonance structure algorithms relevant to the current molecule.

    Takes a dictionary of features generated by analyze_molecule().
    Returns a list of resonance algorithms.
    """
    cython.declare(methodList=list)
    methodList = []

    if features is None:
        methodList = [
            generate_ally_delocalization_resonance_structures,
            generate_lone_pair_radical_resonance_structures,
            generate_lone_pair_multiple_bond_resonance_structures,
            generate_lone_pair_radical_multiple_bond_resonance_structures,
            generate_N5ddc_N5tc_resonance_structures,
            generate_birad_multiple_bond_resonance_structures,
            generate_aromatic_resonance_structures,
            generate_kekule_structure,
            generate_opposite_kekule_structure,
            generate_clar_structures,
        ]
    else:
        # If the molecule is aromatic, then radical resonance has already been considered
        # If the molecule was falsely identified as aromatic, then isArylRadical will still accurately capture
        # cases where the radical is in an orbital that is orthogonal to the pi orbitals.
        if features['isRadical'] and not features['isAromatic'] and not features['isArylRadical']:
            methodList.append(generate_ally_delocalization_resonance_structures)
        if features['hasNitrogen']:
            methodList.append(generate_N5ddc_N5tc_resonance_structures)
        if features['hasLonePairs']:
            methodList.append(generate_lone_pair_radical_resonance_structures)
            methodList.append(generate_lone_pair_multiple_bond_resonance_structures)
            methodList.append(generate_lone_pair_radical_multiple_bond_resonance_structures)
        if features['isBirad']:
            methodList.append(generate_birad_multiple_bond_resonance_structures)
        if features['isDiatomic']:
            methodList.append(generate_OS_resonance_structures)

    return methodList


def analyze_molecule(mol):
    """
    Identify key features of molecule important for resonance structure generation.

    Returns a dictionary of features.
    """
    cython.declare(features=dict)

    features = {'isRadical': mol.isRadical(),
                'isCyclic': mol.isCyclic(),
                'isAromatic': False,
                'isPolycyclicAromatic': False,
                'isArylRadical': False,
                'hasNitrogen': False,
                'hasLonePairs': False,
                'isBirad': False,
                'isDiatomic': False,
                }

    if features['isCyclic']:
        aromaticRings = mol.getAromaticRings()[0]
        if len(aromaticRings) > 0:
            features['isAromatic'] = True
        if len(aromaticRings) > 1:
            features['isPolycyclicAromatic'] = True
        if features['isRadical'] and features['isAromatic']:
            features['isArylRadical'] = mol.isArylRadical(aromaticRings)
    for atom in mol.vertices:
        if atom.isNitrogen():
            features['hasNitrogen'] = True
        if atom.lonePairs > 0:
            features['hasLonePairs'] = True
    if mol.getRadicalCount() >= 2:
            features['isBirad'] = True
    if len(mol.vertices) == 2:
            features['isDiatomic'] = True

    return features


def generate_resonance_structures(mol, clarStructures=True, keepIsomorphic=False, filterStructures=True):
    """
    Generate and return all of the resonance structures for the input molecule.

    Most of the complexity of this method goes into handling aromatic species, particularly to generate an accurate
    set of resonance structures that is consistent regardless of the input structure. The following considerations
    are made:

    1. False positives from RDKit aromaticity detection can occur if a molecule has exocyclic double bonds
    2. False negatives from RDKit aromaticity detection can occur if a radical is delocalized into an aromatic ring
    3. sp2 hybridized radicals in the plane of an aromatic ring do not participate in hyperconjugation
    4. Non-aromatic resonance structures of PAHs are not important resonance contributors (assumption)

    Aromatic species are broken into the following categories for resonance treatment:

    - Radical polycyclic aromatic species: Kekule structures are generated in order to generate adjacent resonance
    structures. The resulting structures are then used for Clar structure generation. After all three steps, any
    non-aromatic structures are removed, under the assumption that they are not important resonance contributors.
    - Radical monocyclic aromatic species: Kekule structures are generated along with adjacent resonance structures.
    All are kept regardless of aromaticity because the radical is more likely to delocalize into the ring.
    - Stable polycyclic aromatic species: Clar structures are generated
    - Stable monocyclic aromatic species: Kekule structures are generated
    """
    cython.declare(molList=list, newMolList=list, features=dict, methodList=list)

    # Check that mol is a valid structure in terms of atomTypes and net charge. Since SMILES with hypervalance
    # heteroatoms are not always read correctly, print a suggestion to input the structure using an adjList.
    try:
        mol.update()
    except AtomTypeError:
        logging.error("The following molecule has at least one atom with an undefined atomType:\n{0}"
                      "\nIf this structure was entered in SMILES, try using the adjacencyList format for an unambiguous"
                      " definition.".format(mol.toAdjacencyList()))
        raise
    if mol.getNetCharge() != 0:
        raise ValueError("Got the following structure:\nSMILES: {0}\nAdjacencyList:\n{1}\nNet charge: {2}\n\n"
                         "Currently RMG cannot process charged species correctly."
                         "\nIf this structure was entered in SMILES, try using the adjacencyList format for an"
                         " unambiguous definition.".format(mol.toSMILES(),mol.toAdjacencyList(),mol.getNetCharge()))

    assert mol.reactive, 'Can only generate resonance structures for reactive molecules! Got the following unreactive' \
                         ' structure:\n{0}Reactive = {1}'.format(mol.toAdjacencyList(),mol.reactive)

    molList = [mol]

    # Analyze molecule
    features = analyze_molecule(mol)

    # Use generate_aromatic_resonance_structures to check for false positives and negatives
    if features['isAromatic'] or (features['isCyclic'] and features['isRadical'] and not features['isArylRadical']):
        newMolList = generate_aromatic_resonance_structures(mol, features)
        if len(newMolList) == 0:
            # Encountered false positive, ie. the molecule is not actually aromatic
            features['isAromatic'] = False
            features['isPolycyclicAromatic'] = False
        else:
            features['isAromatic'] = True
            if len(newMolList[0].getAromaticRings()[0]) > 1:
                features['isPolycyclicAromatic'] = True
    else:
        newMolList = []

    # Special handling for aromatic species
    if len(newMolList) > 0:
        if features['isRadical'] and not features['isArylRadical']:
            if features['isPolycyclicAromatic']:
                if clarStructures:
                    _generate_resonance_structures(newMolList, [generate_kekule_structure], keepIsomorphic)
                    _generate_resonance_structures(newMolList, [generate_ally_delocalization_resonance_structures], keepIsomorphic)
                    _generate_resonance_structures(newMolList, [generate_clar_structures], keepIsomorphic)
                    # Remove non-aromatic structures under the assumption that they aren't important resonance contributors
                    newMolList = [m for m in newMolList if m.isAromatic()]
                else:
                    pass
            else:
                _generate_resonance_structures(newMolList, [generate_kekule_structure,
                                                            generate_opposite_kekule_structure], keepIsomorphic)
                _generate_resonance_structures(newMolList, [generate_ally_delocalization_resonance_structures], keepIsomorphic)
        elif features['isPolycyclicAromatic']:
            if clarStructures:
                _generate_resonance_structures(newMolList, [generate_clar_structures], keepIsomorphic)
            else:
                pass
        else:
            # The molecule is an aryl radical or stable mono-ring aromatic
            # In this case, generate the kekulized form
            _generate_resonance_structures(newMolList, [generate_kekule_structure,
                                                        generate_opposite_kekule_structure], keepIsomorphic)

        # Check for isomorphism against the original molecule
        for i, newMol in enumerate(newMolList):
            if not keepIsomorphic and mol.isIsomorphic(newMol):
                # There will be at most one isomorphic molecule, since the new molecules have
                # already been checked against each other, so we can break after removing it
                del newMolList[i]
                break
            elif keepIsomorphic and mol.isIdentical(newMol):
                del newMolList[i]
                break
        # Add the newly generated structures to the original list
        # This is not optimal, but is a temporary measure to ensure compatibility until other issues are fixed
        molList.extend(newMolList)

    # Generate remaining resonance structures
    methodList = populate_resonance_algorithms(features)
    _generate_resonance_structures(molList, methodList, keepIsomorphic)

    if filterStructures:
        return filter_resonance_structures(molList)

    return molList

def _generate_resonance_structures(molList, methodList, keepIsomorphic=False, copy=False):
    """
    Iteratively generate all resonance structures for a list of starting molecules using the specified methods.

    Args:
        molList             starting list of molecules
        methodList          list of resonance structure algorithms
        keepIsomorphic      if False, removes any structures that give isIsomorphic=True (default)
                            if True, only remove structures that give isIdentical=True
        copy                if False, append new resonance structures to input list (default)
                            if True, make a new list with all of the resonance structures
    """
    cython.declare(index=cython.int, molecule=Molecule, newMolList=list, newMol=Molecule, mol=Molecule)

    if copy:
        # Make a copy of the list so we don't modify the input list
        molList = molList[:]

    # Iterate over resonance structures
    index = 0
    while index < len(molList):
        molecule = molList[index]
        newMolList = []

        for method in methodList:
            newMolList.extend(method(molecule))

        for newMol in newMolList:
            # Append to structure list if unique
            for mol in molList:
                if not keepIsomorphic and mol.isIsomorphic(newMol):
                    break
                elif keepIsomorphic and mol.isIdentical(newMol):
                    break
            else:
                molList.append(newMol)
        if index % 100 == 0 and index != 0:  # While this condition is not expected to be triggered frequently, it is
            # important in order to avoid near infinite looping in systems involving many adjacent heteroatoms.
            # Here we apply filtering to `molList` (even if filterStructures=False) per 100 entries starting at
            # index = 100 , to speed up the resonance structure generation and to avoid potential slowdowns.
            # An example that triggers is S(=O)(S(=O)[O])[O] where the correct reactive structure is S(=S(=O)=O)(=O)=O.
            logging.info('Reached {0} resonance structures for {1}, applying filtration for {2} remaining unexplored'
                          ' structures'.format(index, molList[0].toSMILES(), len(molList) - index))
            molList = molList[:index] + filter_resonance_structures(molList[index:], markNonReactive=False)

        # Move to next resonance isomer
        index += 1

    return molList


def filter_resonance_structures(molList, markNonReactive=True):
    """
    We often get too many resonance structures from the combination of all rules for species containing lonePairs.
    Here we filter them out by minimizing the number of N/S/O atoms without a full octet.
    For example, w/o filtering we may generate >80 resonance structures for [N]=NON=O,
    vs. only 3 resonance structures after filtering.
    """
    cython.declare(octetDeviation=cython.int, octetDeviationList=list, minOctetDeviation=cython.int,
                   filteredList=list, chargedList=list, chargeSpanList=list, minChargeSpan=cython.int,
                   minNumRads=cython.int, maxNumRads=cython.int, sortingList=list, valElectrons=cython.int,
                   index=cython.int, mol=Molecule, atom=Atom, atom2=Atom, bond=Bond)

    # from rmgpy.rmg.input import get_species_constaints

    octetDeviationList = []
    for mol in molList:
        octetDeviation = 0  # This is the accumulated "score" for each molecule
        for atom in mol.vertices:
            valElectrons = 2 * (int(atom.getBondOrdersForAtom()) + atom.lonePairs) + atom.radicalElectrons  # val. electrons
            if atom.isCarbon():
                octetDeviation += abs(8 - valElectrons)  # expecting C to be near octet
            elif atom.isNitrogen():
                if atom.lonePairs:
                    octetDeviation += abs(8 - valElectrons)  # expecting N p1/2/3 to be near octet
                else:
                    octetDeviation += min(abs(10 - valElectrons), abs(8 - valElectrons))  # N p0 could be near octed or dectet
                    # N p0 could in fact be close to an octet rather than a dectet such as in O=[N+][O-]
                if valElectrons > 8:
                    octetDeviation += 1  # penalty for N with valance greater than 8 (as in O=[N.]=O,
                    # [NH2.]=[:NH.], N#[N.]O, CCN=N#N)
            elif atom.isOxygen():
                octetDeviation += abs(8 - valElectrons)  # expecting O to be near octet
                if atom.atomType.label in ['O4sc', 'O4dc', 'O4tc']:
                    octetDeviation += 1  # penalty for O p1 c+1
                    # as in [N-2][N+]#[O+], [O-]S#[O+], OS(S)([O-])#[O+], [OH+]=S(O)(=O)[O-], [OH.+][S-]=O.
                    # [C-]#[O+] and [O-][O+]=O which are correct structures also get penalized here, but that's OK
                    # since they are still eventually selected as representative structures according to the rules here.
            elif atom.isSulfur():
                if atom.lonePairs == 0:
                    octetDeviation += abs(12 - valElectrons)  # duodectet on S p0, eg O=S(=O)(O)O val 12, O[S](=O)=O val 11
                elif atom.lonePairs == 1:
                    octetDeviation += min(abs(8 - valElectrons), abs(10 - valElectrons))  # octet/dectet on S p1,
                    # eg [O-][S+]=O val 8, O[S]=O val 9, OS([O])=O val 10
                elif atom.lonePairs == 2:
                    octetDeviation += min(abs(8 - valElectrons), abs(10 - valElectrons))  # octet/dectet on S p2,
                    # eg [S][S] val 7, OS[O] val 8, [NH+]#[N+][S-][O-] val 9, O[S-](O)[N+]#N val 10
                elif atom.lonePairs == 3:
                    octetDeviation += abs(8 - valElectrons)  # octet on S p3, eg [S-][O+]=O
                for atom2, bond in atom.bonds.iteritems():
                    if atom2.isSulfur() and bond.isTriple():
                        octetDeviation += 1  # penalty for S#S substructures. Often times sulfur can have a triple
                        # bond to another sulfur in a structure that obeys the octet rule, but probably shouldn't be a
                        # correct resonance structure. This adds to the combinatorial effect of resonance structures
                        # when generating reactions, yet probably isn't too important for reactivity.
                        # Examples: CS(=O)SC <=> CS(=O)#SC;
                        # [O.]OSS[O.] <=> [O.]OS#S[O.] <=> [O.]OS#[S.]=O; N#[N+]SS[O-] <=> N#[N+]C#S[O-]
            if pathfinder.is_OS(mol) and atom.radicalElectrons >= 2:
                octetDeviation += atom.radicalElectrons + 1  # This helps to distinguish between a birad site and two
                # adjacent radicals on S2 or SO structures, e.g., [::O.][::S.] vs. [::O]=[:S..]
        octetDeviationList.append(octetDeviation)
        if len(octetDeviationList) == 1 or (minOctetDeviation and octetDeviation < minOctetDeviation):
            minOctetDeviation = octetDeviation

    # Filtering using the octet deviation criterion rules out most unrepresentative structures. However, since some
    # charge-strained species are still kept (e.g., [NH]N=S=O <-> [NH+]#[N+][S-][O-]) we also generate during the same
    # loop a chargeSpanList to keep track of the charge spans. This will be used downstream for further filtering.
    # This loop is also used to find the minimal multiplicity value in the filtered list
    filteredList = []
    chargeSpanList = []
    for index in xrange(len(molList)):
        if octetDeviationList[index] == minOctetDeviation:  # legacy octet filtration
            filteredList.append(molList[index])
            chargeSpanList.append(molList[index].getChargeSpan())
            if len(chargeSpanList) == 1 or (minChargeSpan and chargeSpanList[-1] < minChargeSpan):
                minChargeSpan = chargeSpanList[-1]

    # Filter by charge span.
    #
    # If the species is a radical we first check whether keeping an extra charge span separation might be important for
    # reactivity by relocating the radical site. If so, wee keep it.
    # For example:
    # - Both of NO2's resonance structures will be kept: [O]N=O <=> O=[N+.][O-]
    # - NCO will only have two resonance structures [N.]=C=O <=> N#C[O.], and will loose the third structure which has
    #   the same octet deviation, has a charge separation, but the radical site has already been considered: [N+.]#C[O-]
    # - CH2NO keeps all three structures, since a new radical site is introduced: [CH2.]N=O <=> C=N[O.] <=> C=[N+.][O-]
    #
    # However, if the species is not a radical we only keep the structures with the minimal charge span.
    # For example:
    # - NSH will only keep N#S and not [N-]=[SH+]
    # - The following species will loose two thirds of its resonance structures, which are charged: CS(=O)SC <=>
    #   CS(=O)#SC <=> C[S+]([O-]SC <=> CS([O-])=[S+]C <=> C[S+]([O-])#SC <=> C[S+](=O)=[S-]C
    # - The azide structure is know to have three resonance structures: [NH-][N+]#N <=> N=[N+]=[N-] <=> [NH+]#[N+][N-2];
    #   here we'll lose the third one, which is theoretically "true", but doesn't contribute to reactivity.
    if len(set(chargeSpanList)) > 1 and molList[0].isRadical():
        # Proceed only if there are structures with different charge spans and the species is a radical.
        chargedList = [filteredList[index] for index in xrange(len(filteredList)) if
                        chargeSpanList[index] == minChargeSpan + 1]  # save the 2nd charge span layer in a temp list
        filteredList = [filteredList[index] for index in xrange(len(filteredList)) if
                        chargeSpanList[index] == minChargeSpan]  # keep at least one charge span layer
        # Find the radical sites in all filteredList structures:
        sortingList = []
        for mol in filteredList:
            for atom in mol.vertices:
                if atom.radicalElectrons:
                    sortingList.append(int(atom.sortingLabel))
        # Find unique radical sites in chargedList and append these structures to filteredList:
        for mol in chargedList:
            for atom in mol.vertices:
                if atom.radicalElectrons and int(atom.sortingLabel) not in sortingList:
                    filteredList.append(mol)
    else:
        filteredList = [filteredList[index] for index in xrange(len(filteredList)) if
                        chargeSpanList[index] == minChargeSpan]  # keep one charge span layer for non-rads

    if markNonReactive:
        # Special treatment for O=O, S=S, S=O, where the correct ground state structure is being filtered out due to a
        # higher octet deviation
        if (pathfinder.is_OS(filteredList[0])):
            # if not (pathfinder.is_OS(filteredList[0]) == 2 and get_species_constaints('allowSingletO2')):
            if not (pathfinder.is_OS(filteredList[0]) == 2):
                # This is either O2, S2, or SO. If the user chose to allowSingletO2, then this is not the singlet state.
                for mol in filteredList:
                    if pathfinder.is_OS(mol) != 1:  # This is not the triplet ground state [O][O], [S][S], or [S][O]
                        mol.reactive = False
                for mol in filteredList:
                    if pathfinder.is_OS(mol) == 1:  # Check whether filteredList already contains the ground state
                        break
                else:  # the ground state was filtered out, append it to filteredList
                    for mol in molList:
                        if pathfinder.is_OS(mol) == 1:  # Check if mol is the ground state structure, e.g., [O][O] etc.
                            filteredList.append(mol)   # If so, append mol (as the reactive structure)
        # Special treatment for generate_birad_multiple_bond_resonance_structures, where excited states should be marked
        # as non-reactive
        else:
            minNumRads = maxNumRads = filteredList[0].getRadicalCount()
            for mol in filteredList:
                if mol.getRadicalCount() < minNumRads:
                    minNumRads = mol.getRadicalCount()
                elif mol.getRadicalCount() > maxNumRads:
                    maxNumRads = mol.getRadicalCount()
            if maxNumRads != minNumRads:  # mark as non-reactive only if the species contains structures with
                # different number of radicals
                for mol in filteredList:
                    if mol.getRadicalCount() > minNumRads:
                        mol.reactive = False
                        logging.debug('marked structure {0} as non-reactive'.format(mol))

        # sort all structures in filteredList so that the reactive ones are first
        filteredList.sort(key=lambda mol: mol.reactive, reverse=True)

        # Make sure that the first original structure is also first in the list (unless it was filtered out).
        # Important whenever Species.molecule[0] is expected to be used (e.g., training reactions) after generating the
        # resonance structures.
        for index in xrange(len(filteredList)):
            if filteredList[index].isIsomorphic(molList[0]):
                filteredList.insert(0, filteredList.pop(index))
                break
        else:
            # Append the original structure to molList and set `reactive` to `False`.
            # This structure may very well deviate from the octet rule or have other attributes by which it should have
            # been filtered out. However, for processing reactions (e.g., degeneracy calculations) it should be kept
            # (e.g., [::N]O <=> [::N][::O.] + [H.], where [::N][::O.] should be recognized as [:N.]=[::O]).
            molList[0].reactive = False
            filteredList.append(molList[0])

    # Check that there's at least one reactive structure in the returned list
    if any([mol.reactive for mol in filteredList]):
        return filteredList
    else:
        logging.error('No reactive structures were attributed to species {0}'.format(filteredList[0].toSMILES()))
        for mol in filteredList:
            logging.info('Structure: {0}\n{1}Reactive: {2}'.format(mol.toSMILES(),mol.toAdjacencyList(),mol.reactive))
            logging.info('\n')
        raise AssertionError('Each species must have at least one reactive structure. Something went wrong'
                             ' when processing species {0}'.format(filteredList[0].toSMILES()))


def generate_ally_delocalization_resonance_structures(mol):
    """
    Generate all of the resonance structures formed by one allyl radical shift.

    Biradicals on a single atom are not supported.
    """
    cython.declare(structures=list, paths=list, index=cython.int, structure=Molecule)
    cython.declare(atom=Atom, atom1=Atom, atom2=Atom, atom3=Atom, bond12=Bond, bond23=Bond)
    cython.declare(v1=Vertex, v2=Vertex)

    structures = []
    if mol.isRadical():  # Iterate over radicals in structure
        for atom in mol.vertices:
            paths = pathfinder.find_allyl_delocalization_paths(atom)
            for atom1, atom2, atom3, bond12, bond23 in paths:
                # Adjust to (potentially) new resonance structure
                atom1.decrementRadical()
                atom3.incrementRadical()
                bond12.incrementOrder()
                bond23.decrementOrder()
                # Make a copy of isomer
                structure = mol.copy(deep=True)
                # Also copy the connectivity values, since they are the same
                # for all resonance structures
                for index in xrange(len(mol.vertices)):
                    v1 = mol.vertices[index]
                    v2 = structure.vertices[index]
                    v2.connectivity1 = v1.connectivity1
                    v2.connectivity2 = v1.connectivity2
                    v2.connectivity3 = v1.connectivity3
                    v2.sortingLabel = v1.sortingLabel
                # Restore current structure
                atom1.incrementRadical()
                atom3.decrementRadical()
                bond12.decrementOrder()
                bond23.incrementOrder()
                try:
                    structure.updateAtomTypes(logSpecies=False)
                except AtomTypeError:
                    pass  # Don't append resonance structure if it creates an undefined atomType
                else:
                    structures.append(structure)
    return structures


def generate_lone_pair_radical_resonance_structures(mol):
    """
    Generate all of the resonance structures formed by lone electron pair - radical shifts.
    These resonance transformations do not involve changing bond orders.
    NO2 example: O=[:N]-[::O.] <=> O=[N.+]-[:::O-]
    (where ':' denotes a lone pair, '.' denotes a radical, '-' not in [] denotes a single bond, '-'/'+' denote charge)
    """
    cython.declare(structures=list, paths=list, index=cython.int, structure=Molecule)
    cython.declare(atom=Atom, atom1=Atom, atom2=Atom)
    cython.declare(v1=Vertex, v2=Vertex)

    structures = []
    if mol.isRadical():  # Iterate over radicals in structure
        for atom in mol.vertices:
            if atom.isNOS():
                paths = pathfinder.find_lone_pair_radical_delocalization_paths(atom)
                for atom1, atom2 in paths:
                    # Adjust to (potentially) new resonance structure
                    atom1.decrementRadical()
                    atom1.incrementLonePairs()
                    atom1.updateCharge()
                    atom2.incrementRadical()
                    atom2.decrementLonePairs()
                    atom2.updateCharge()
                    # Make a copy of structure
                    structure = mol.copy(deep=True)
                    # Also copy the connectivity values, since they are the same
                    # for all resonance structures
                    for index in xrange(len(mol.vertices)):
                        v1 = mol.vertices[index]
                        v2 = structure.vertices[index]
                        v2.connectivity1 = v1.connectivity1
                        v2.connectivity2 = v1.connectivity2
                        v2.connectivity3 = v1.connectivity3
                        v2.sortingLabel = v1.sortingLabel
                    # Restore current structure
                    atom1.incrementRadical()
                    atom1.decrementLonePairs()
                    atom1.updateCharge()
                    atom2.decrementRadical()
                    atom2.incrementLonePairs()
                    atom2.updateCharge()
                    try:
                        structure.updateAtomTypes(logSpecies=False)
                    except AtomTypeError:
                        pass  # Don't append resonance structure if it creates an undefined atomType
                    else:
                        structures.append(structure)
    return structures


def generate_lone_pair_multiple_bond_resonance_structures(mol):
    """
    Generate all of the resonance structures formed by lone electron pair - multiple bond shifts.
    This function deals with TWO very similar resonance structures, depending whether or not a radical is present:
    - rad N/S/O multiple bond <=> non-radical N/S/O w/ added lonePair and decremented bond (rad gain on other atom)
    - non-rad N/S/O multiple bond <=> non-radical N/S/O w/ added lonePair and decremented bond
    Two simple examples are [N]=C and N=C, respectively:
    - [:N.]=[CH2] <=> [::N]-[.CH2]
    - [:NH]=[CH2] <=> [::NH-]-[CH2+]
    (where ':' denotes a lone pair, '.' denotes a radical, '-' not in [] denotes a single bond, '-'/'+' denote charge)
    Although these are different resonance transformations, their algorithm is identical
    except for loosing/gaining a radical if a radical exists.
    Here atom1 refers to the N/S/O atom, atom 2 refers to the any R!H (atom2's lonePairs aren't affected)
    (In direction 1 atom1 <losses> a lone pair, in direction 2 atom1 <gains> a lone pair)
    """
    cython.declare(structures=list, paths=list, index=cython.int, structure=Molecule, direction=cython.int)
    cython.declare(atom=Atom, atom1=Atom, atom2=Atom, bond12=Bond)
    cython.declare(v1=Vertex, v2=Vertex)

    structures = []
    for atom in mol.vertices:
        if atom.isNOS():
            paths = pathfinder.find_lone_pair_multiple_bond_delocalization_paths(atom)
            for atom1, atom2, bond12, direction in paths:
                if direction == 1:  # The direction <increasing> the bond order
                    atom1.decrementLonePairs()
                    bond12.incrementOrder()
                elif direction == 2:  # The direction <decreasing> the bond order
                    atom1.incrementLonePairs()
                    bond12.decrementOrder()
                atom1.updateCharge()
                atom2.updateCharge()
                # Make a copy of structure
                structure = mol.copy(deep=True)
                # Also copy the connectivity values, since they are the same
                # for all resonance structures
                for index in xrange(len(mol.vertices)):
                    v1 = mol.vertices[index]
                    v2 = structure.vertices[index]
                    v2.connectivity1 = v1.connectivity1
                    v2.connectivity2 = v1.connectivity2
                    v2.connectivity3 = v1.connectivity3
                    v2.sortingLabel = v1.sortingLabel
                # Restore current structure
                if direction == 1:  # The direction <increasing> the bond order
                    atom1.incrementLonePairs()
                    bond12.decrementOrder()
                elif direction == 2:  # The direction <decreasing> the bond order
                    atom1.decrementLonePairs()
                    bond12.incrementOrder()
                atom1.updateCharge()
                atom2.updateCharge()
                try:
                    structure.updateAtomTypes(logSpecies=False)
                except AtomTypeError:
                    pass  # Don't append resonance structure if it creates an undefined atomType
                else:
                    structures.append(structure)
    return structures


def generate_lone_pair_radical_multiple_bond_resonance_structures(mol):
    """
    Generate all of the resonance structures formed by lone electron pair - radical - multiple bond shifts.
    Example: [:N.]=[CH2] <=> [::N]-[.CH2]
    (where ':' denotes a lone pair, '.' denotes a radical, '-' not in [] denotes a single bond, '-'/'+' denote charge)
    Here atom1 refers to the N/S/O atom, atom 2 refers to the any R!H (atom2's lonePairs aren't affected)
    This function is similar to generate_lone_pair_multiple_bond_resonance_structures() except for dealing with the
    radical transformations.
    (In direction 1 atom1 <losses> a lone pair, gains a radical, and atom2 looses a radical.
    In direction 2 atom1 <gains> a lone pair, looses a radical, and atom2 gains a radical)
    """
    cython.declare(structures=list, paths=list, index=cython.int, structure=Molecule, direction=cython.int)
    cython.declare(atom=Atom, atom1=Atom, atom2=Atom, bond12=Bond)
    cython.declare(v1=Vertex, v2=Vertex)

    structures = []
    if mol.isRadical():  # Iterate over radicals in structure
        for atom in mol.vertices:
            if atom.isNOS():
                paths = pathfinder.find_lone_pair_radical_multiple_bond_delocalization_paths(atom)
                for atom1, atom2, bond12, direction in paths:
                    if direction == 1:  # The direction <increasing> the bond order
                        atom1.decrementLonePairs()
                        bond12.incrementOrder()
                        atom1.incrementRadical()
                        atom2.decrementRadical()
                    elif direction == 2:  # The direction <decreasing> the bond order
                        atom1.incrementLonePairs()
                        bond12.decrementOrder()
                        atom1.decrementRadical()
                        atom2.incrementRadical()
                    atom1.updateCharge()
                    atom2.updateCharge()
                    # Make a copy of structure
                    structure = mol.copy(deep=True)
                    # Also copy the connectivity values, since they are the same
                    # for all resonance structures
                    for index in xrange(len(mol.vertices)):
                        v1 = mol.vertices[index]
                        v2 = structure.vertices[index]
                        v2.connectivity1 = v1.connectivity1
                        v2.connectivity2 = v1.connectivity2
                        v2.connectivity3 = v1.connectivity3
                        v2.sortingLabel = v1.sortingLabel
                    # Restore current structure
                    if direction == 1:  # The direction <increasing> the bond order
                        atom1.incrementLonePairs()
                        bond12.decrementOrder()
                        atom1.decrementRadical()
                        atom2.incrementRadical()
                    elif direction == 2:  # The direction <decreasing> the bond order
                        atom1.decrementLonePairs()
                        bond12.incrementOrder()
                        atom1.incrementRadical()
                        atom2.decrementRadical()
                    atom1.updateCharge()
                    atom2.updateCharge()
                    try:
                        structure.updateAtomTypes(logSpecies=False)
                    except AtomTypeError:
                        pass  # Don't append resonance structure if it creates an undefined atomType
                    else:
                        structures.append(structure)
    return structures


def generate_N5ddc_N5tc_resonance_structures(mol):
    """
    Generate all of the resonance structures formed by shifts between N5dd and N5ts.
    """
    cython.declare(structures=list, paths=list, index=cython.int, structure=Molecule)
    cython.declare(atom=Atom, atom1=Atom, atom2=Atom, atom3=Atom, bond12=Bond, bond23=Bond)
    cython.declare(v1=Vertex, v2=Vertex)

    structures = []
    for atom in mol.vertices:
        if atom.atomType.label in ['N5ddc','N5tc'] and atom.radicalElectrons == 0:
            paths = pathfinder.find_N5ddc_N5tc_delocalization_paths(atom)
            for atom1, atom2, atom3, bond12, bond23 in paths:
                atom2.decrementLonePairs()
                atom3.incrementLonePairs()
                bond12.incrementOrder()
                bond23.decrementOrder()
                atom1.updateCharge()
                atom2.updateCharge()
                atom3.updateCharge()
                # Make a copy of structure
                structure = mol.copy(deep=True)
                # Also copy the connectivity values, since they are the same
                # for all resonance structures
                for index in xrange(len(mol.vertices)):
                    v1 = mol.vertices[index]
                    v2 = structure.vertices[index]
                    v2.connectivity1 = v1.connectivity1
                    v2.connectivity2 = v1.connectivity2
                    v2.connectivity3 = v1.connectivity3
                    v2.sortingLabel = v1.sortingLabel
                # Restore current structure
                atom2.incrementLonePairs()
                atom3.decrementLonePairs()
                bond12.decrementOrder()
                bond23.incrementOrder()
                atom1.updateCharge()
                atom2.updateCharge()
                atom3.updateCharge()
                try:
                    structure.updateAtomTypes(logSpecies=False)
                except AtomTypeError:
                    pass  # Don't append resonance structure if it creates an undefined atomType
                else:
                    structures.append(structure)
    return structures


def generate_birad_multiple_bond_resonance_structures(mol):
    """
    Generate all of the resonance structures formed by relaxation of an excited two adjacent radicals state to a
    multiple bond state. This is a unidirectional transition (i.e., if the [O.][S.]=O structure is present in the system
    it should be marked as `.reactive=False` and the reactive structure O=S=O is added to the molecule list. However, if
    O=S=O is present is the system, this doesn't necessarily mean that the excited [O.][S.]=O structure is generated.
    This function should NOT convert ground state [O.][O.] into an excited O=O state (or its isoelectronic structures
    [S.][S.] and [S.][O.]).
    This should target the following transitions:
    - [:N.]=[:N.] => N#N
    - [O.][S.](=O)=O => O=S(=O)=O
    - [O.][:S.]=O => O=S=O
    - C=[S+][C.]([O.])[S-] => C=[S+]C(=O)[S-]
    - [CH2.][CH2.] => C=C
    (where ':' denotes a lone pair, '.' denotes a radical, '-' not in [] denotes a single bond, '-'/'+' denote charge)
    * This is treated as a resonance structure and not a family since: (a) otherwise the excited species and all of its
    resonance structures will still be reactive and contribute to the combinatorial complexity of the system; (b) each
    model that involves [O][O] will have (at least in the edge) the excited O=O state due to the reverse reaction in the
    family.
    """
    cython.declare(structures=list, paths=list, index=cython.int, structure=Molecule)
    cython.declare(atom=Atom, atom1=Atom, atom2=Atom, bond12=Bond)
    cython.declare(v1=Vertex, v2=Vertex)

    # from rmgpy.rmg.input import get_species_constaints

    structures = []
    # if mol.isRadical() and pathfinder.is_OS(mol) == 0 and not get_species_constaints('allowAdjacentRadicals'):
    if mol.isRadical() and pathfinder.is_OS(mol) == 0:
        # This is neither O2, S2, SO, and the user did not specify "allowAdjacentRadicals=True" in the input file
        for atom in mol.vertices:
            if atom.radicalElectrons:
                paths = pathfinder.find_birad_multiple_bond_delocalization_paths(atom)
                for atom1, atom2, bond12 in paths:
                    atom1.decrementRadical()
                    atom2.decrementRadical()
                    bond12.incrementOrder()
                    atom1.updateCharge()
                    atom2.updateCharge()
                    # Make a copy of structure
                    structure = mol.copy(deep=True)
                    # Also copy the connectivity values, since they are the same
                    # for all resonance structures
                    for index in xrange(len(mol.vertices)):
                        v1 = mol.vertices[index]
                        v2 = structure.vertices[index]
                        v2.connectivity1 = v1.connectivity1
                        v2.connectivity2 = v1.connectivity2
                        v2.connectivity3 = v1.connectivity3
                        v2.sortingLabel = v1.sortingLabel
                    # Restore current structure
                    atom1.incrementRadical()
                    atom2.incrementRadical()
                    bond12.decrementOrder()
                    atom1.updateCharge()
                    atom2.updateCharge()
                    try:
                        # update both atomTypes and multiplicity
                        structure.update(log_species_while_updating_atom_types=False)
                    except AtomTypeError:
                        pass  # Don't append resonance structure if it creates an undefined atomType
                    else:
                        structures.append(structure)
    return structures


def generate_OS_resonance_structures(mol):
    """
    This is a complementary function to generate_birad_multiple_bond_resonance_structures(), and deals with the opposite
    case of three specific isoelectronic structures: O=O, S=S, and S=O. Here the transition is from a double bond
    structure into a single bond structure with two adjacent radicals. This is also a unidirectional transition (i.e.,
    if the O=O structure is present in the system it should be marked as `.reactive=False` and the reactive structure
    [O.][O.] is added to the molecule list.
    This function assumes that mol consists of two atoms only, which should be checked by the calling function.
    This transition function is disabled if the user chooses to allow singlet oxygen in the input file (in which case,
    the user is responsible to rates for the transition in the form of a family or a library).
    """
    cython.declare(index=cython.int, structure=Molecule)
    cython.declare(atom=Atom, atom1=Atom, atom2=Atom, bond12=Bond)
    cython.declare(v1=Vertex, v2=Vertex)

    # from rmgpy.rmg.input import get_species_constaints

    # if pathfinder.is_OS(mol) == 2 and not get_species_constaints('allowSingletO2'):  # check if mol is the excited state, e.g., O=O
    if pathfinder.is_OS(mol) == 2:  # check if mol is the excited state, e.g., O=O
        # This is either O=O, S=S, or S=O, and the user did not specify "allowSingletO2=True" in the input file
        mol.vertices[0].incrementRadical()
        mol.vertices[1].incrementRadical()
        mol.vertices[0].bonds[mol.vertices[1]].decrementOrder()
        # Make a copy of structure
        structure = mol.copy(deep=True)
        # Also copy the connectivity values, since they are the same
        # for all resonance structures
        for index in xrange(len(mol.vertices)):
            v1 = mol.vertices[index]
            v2 = structure.vertices[index]
            v2.connectivity1 = v1.connectivity1
            v2.connectivity2 = v1.connectivity2
            v2.connectivity3 = v1.connectivity3
            v2.sortingLabel = v1.sortingLabel
        # Restore current structure
        mol.vertices[0].decrementRadical()
        mol.vertices[1].decrementRadical()
        mol.vertices[0].bonds[mol.vertices[1]].incrementOrder()
        try:
            structure.update(log_species_while_updating_atom_types=False)  # update both atomTypes and multiplicity
        except AtomTypeError:
            pass  # Don't append resonance structure if it creates an undefined atomType
        else:
            return [structure]
    return []


def generate_aromatic_resonance_structures(mol, features=None):
    """
    Generate the aromatic form of the molecule. For radicals, generates the form with the most aromatic rings.

    Returns result as a list.
    In most cases, only one structure will be returned.
    In certain cases where multiple forms have the same number of aromatic rings, multiple structures will be returned.
    If there's an error (eg. in RDKit) it just returns an empty list.
    """
    cython.declare(molecule=Molecule, rings=list, aromaticBonds=list, kekuleList=list, maxNum=cython.int, molList=list,
                   newMolList=list, ring=list, bond=Bond, order=float, originalBonds=list, originalOrder=list,
                   i=cython.int, counter=cython.int)

    if features is None:
        features = analyze_molecule(mol)

    if not features['isCyclic']:
        return []

    molecule = mol.copy(deep=True)

    # First get all rings in the molecule
    rings = molecule.getAllSimpleCyclesOfSize(6)

    # Then determine which ones are aromatic
    aromaticBonds = molecule.getAromaticRings(rings)[1]

    # If the species is a radical, then there is a chance that the radical can be shifted
    #   to a location that increases the number of perceived aromatic rings.
    if features['isRadical'] and not features['isArylRadical']:
        if molecule.isAromatic():
            kekuleList = generate_kekule_structure(molecule)
        else:
            kekuleList = [molecule]
        _generate_resonance_structures(kekuleList, [generate_ally_delocalization_resonance_structures])

        maxNum = 0
        molList = []

        # Iterate through the adjacent resonance structures and keep the structures with the most aromatic rings
        for mol0 in kekuleList:
            aromaticBonds = mol0.getAromaticRings()[1]
            if len(aromaticBonds) > maxNum:
                maxNum = len(aromaticBonds)
                molList = [(mol0, aromaticBonds)]
            elif len(aromaticBonds) == maxNum:
                molList.append((mol0, aromaticBonds))
    else:
        # Otherwise, it is not possible to increase the number of aromatic rings by moving electrons,
        # so go ahead with the inputted form of the molecule
        molList = [(molecule, aromaticBonds)]

    newMolList = []

    # Generate the aromatic resonance structure(s)
    for mol0, aromaticBonds in molList:
        if not aromaticBonds:
            continue
        # Save original bond orders in case this doesn't work out
        originalBonds = []
        for ring in aromaticBonds:
            originalOrder = []
            for bond in ring:
                originalOrder.append(bond.order)
            originalBonds.append(originalOrder)
        # Change bond types to benzene bonds for all aromatic rings
        for ring in aromaticBonds:
            for bond in ring:
                bond.order = 1.5

        try:
            mol0.updateAtomTypes(logSpecies=False)
        except AtomTypeError:
            # If this didn't work the first time, then there might be a ring that is not actually aromatic
            # Reset our changes
            for ring, originalOrder in itertools.izip(aromaticBonds, originalBonds):
                for bond, order in itertools.izip(ring, originalOrder):
                    bond.order = order
            # Try to make each ring aromatic, one by one
            i = 0
            counter = 0
            while i < len(aromaticBonds) and counter < 2*len(aromaticBonds):
                counter += 1
                originalOrder = []
                for bond in aromaticBonds[i]:
                    originalOrder.append(bond.order)
                    bond.order = 1.5
                try:
                    mol0.updateAtomTypes(logSpecies=False)
                except AtomTypeError:
                    # This ring could not be made aromatic, possibly because it depends on other rings
                    # Undo changes
                    for bond, order in itertools.izip(aromaticBonds[i], originalOrder):
                        bond.order = order
                    # Move it to the end of the list, and go on to the next ring
                    aromaticBonds.append(aromaticBonds.pop(i))
                    mol0.updateAtomTypes(logSpecies=False)
                    continue
                else:
                    # We're done with this ring, so go on to the next ring
                    i += 1
            # If we didn't end up making any of the rings aromatic, then this molecule is not actually aromatic
            if i == 0:
                # Move onto next molecule in the list
                continue

        for mol1 in newMolList:
            if mol1.isIsomorphic(mol0):
                break
        else:
            newMolList.append(mol0)

    return newMolList

def generate_kekule_structure(mol):
    """
    Generate a kekulized (single-double bond) form of the molecule.
    The specific arrangement of double bonds is non-deterministic, and depends on RDKit.

    Returns a single Kekule structure as an element of a list of length 1.
    If there's an error (eg. in RDKit) then it just returns an empty list.
    """
    cython.declare(atom=Atom, molecule=Molecule)

    for atom in mol.atoms:
        if atom.atomType.label == 'Cb' or atom.atomType.label == 'Cbf':
            break
    else:
        return []

    molecule = mol.copy(deep=True)

    try:
        kekulize(molecule)
    except KekulizationError:
        return []

    return [molecule]

def generate_opposite_kekule_structure(mol):
    """
    Generate the Kekule structure with opposite single/double bond arrangement
    for single ring aromatics.

    Returns a single Kekule structure as an element of a list of length 1.
    """

    # This won't work with the aromatic form of the molecule
    if mol.isAromatic():
        return []

    molecule = mol.copy(deep=True)

    aromaticBonds = molecule.getAromaticRings()[1]

    # We can only do this for single ring aromatics for now
    if len(aromaticBonds) != 1:
        return []

    numS = 0
    numD = 0
    for bond in aromaticBonds[0]:
        if bond.isSingle():
            numS += 1
            bond.order = 2
        elif bond.isDouble():
            numD += 1
            bond.order = 1
        else:
            # Something is wrong: there is a bond that is not single or double
            return []

    if numS != 3 or numD != 3:
        return []

    try:
        molecule.updateAtomTypes()
    except AtomTypeError:
        return []
    else:
        return [molecule]

def generate_isomorphic_resonance_structures(mol):
    """
    Select the resonance isomer that is isomorphic to the parameter isomer, with the lowest unpaired
    electrons descriptor.

    We generate over all resonance isomers (non-isomorphic as well as isomorphic) and retain isomorphic
    isomers.

    WIP: do not generate aromatic resonance isomers.
    """

    cython.declare(isomorphic_isomers=list,\
                   isomers=list,
                    )

    cython.declare(isomer=Molecule,\
                   newIsomer=Molecule,\
                   isom=Molecule
                   )

    cython.declare(index=int)

    isomorphic_isomers = [mol]# resonance isomers that are isomorphic to the parameter isomer.

    isomers = [mol]

    # Iterate over resonance isomers
    index = 0
    while index < len(isomers):
        isomer = isomers[index]
        
        newIsomers = []
        for algo in populate_resonance_algorithms():
            newIsomers.extend(algo(isomer))
        
        for newIsomer in newIsomers:
            # Append to isomer list if unique
            for isom in isomers:
                if isom.copy(deep=True).isIsomorphic(newIsomer.copy(deep=True)):
                    isomorphic_isomers.append(newIsomer)
                    break
            else:
                isomers.append(newIsomer)        
                    
        # Move to next resonance isomer
        index += 1

    return isomorphic_isomers


def generate_clar_structures(mol):
    """
    Generate Clar structures for a given molecule.

    Returns a list of :class:`Molecule` objects corresponding to the Clar structures.
    """
    cython.declare(output=list, molList=list, newmol=Molecule, aromaticRings=list, bonds=list, solution=list,
                   y=list, x=list, index=cython.int, bond=Bond, ring=list)

    if not mol.isCyclic():
        return []

    try:
        output = _clar_optimization(mol)
    except ILPSolutionError:
        # The optimization algorithm did not work on the first iteration
        return []

    molList = []

    for newmol, aromaticRings, bonds, solution in output:

        # The solution includes a part corresponding to rings, y, and a part corresponding to bonds, x, using
        # nomenclature from the paper. In y, 1 means the ring as a sextet, 0 means it does not.
        # In x, 1 corresponds to a double bond, 0 either means a single bond or the bond is part of a sextet.
        y = solution[0:len(aromaticRings)]
        x = solution[len(aromaticRings):]

        # Apply results to molecule - double bond locations first
        for index, bond in enumerate(bonds):
            if x[index] == 0:
                bond.order = 1 # single
            elif x[index] == 1:
                bond.order = 2 # double
            else:
                raise ValueError('Unaccepted bond value {0} obtained from optimization.'.format(x[index]))

        # Then apply locations of aromatic sextets by converting to benzene bonds
        for index, ring in enumerate(aromaticRings):
            if y[index] == 1:
                _clar_transformation(newmol, ring)

        try:
            newmol.updateAtomTypes()
        except AtomTypeError:
            pass
        else:
            molList.append(newmol)

    return molList


def _clar_optimization(mol, constraints=None, maxNum=None):
    """
    Implements linear programming algorithm for finding Clar structures. This algorithm maximizes the number
    of Clar sextets within the constraints of molecular geometry and atom valency.

    Returns a list of valid Clar solutions in the form of a tuple, with the following entries:
        [0] Molecule object
        [1] List of aromatic rings
        [2] List of bonds
        [3] Optimization solution

    The optimization solution is a list of boolean values with sextet assignments followed by double bond assignments,
    with indices corresponding to the list of aromatic rings and list of bonds, respectively.

    Method adapted from:
        Hansen, P.; Zheng, M. The Clar Number of a Benzenoid Hydrocarbon and Linear Programming.
            J. Math. Chem. 1994, 15 (1), 93107.
    """
    cython.declare(molecule=Molecule, aromaticRings=list, exo=list, l=cython.int, m=cython.int, n=cython.int,
                   a=list, objective=list, status=cython.int, solution=list, innerSolutions=list)

    from lpsolve55 import lpsolve
    import signal

    # Save the current signal handler
    sig = signal.getsignal(signal.SIGINT)

    # Make a copy of the molecule so we don't destroy the original
    molecule = mol.copy(deep=True)

    aromaticRings = molecule.getAromaticRings()[0]

    if not aromaticRings:
        return []

    # Get list of atoms that are in rings
    atoms = set()
    for ring in aromaticRings:
        atoms.update(ring)
    atoms = list(atoms)

    # Get list of bonds involving the ring atoms, ignoring bonds to hydrogen
    bonds = set()
    for atom in atoms:
        bonds.update([atom.bonds[key] for key in atom.bonds.keys() if key.isNonHydrogen()])
    bonds = list(bonds)

    # Identify exocyclic bonds, and save their bond orders
    exo = []
    for bond in bonds:
        if bond.atom1 not in atoms or bond.atom2 not in atoms:
            if bond.isDouble():
                exo.append(1)
            else:
                exo.append(0)
        else:
            exo.append(None)

    # Dimensions
    l = len(aromaticRings)
    m = len(atoms)
    n = l + len(bonds)

    # Connectivity matrix which indicates which rings and bonds each atom is in
    # Part of equality constraint Ax=b
    a = []
    for atom in atoms:
        inRing = [1 if atom in ring else 0 for ring in aromaticRings]
        inBond = [1 if atom in [bond.atom1, bond.atom2] else 0 for bond in bonds]
        a.append(inRing + inBond)

    # Objective vector for optimization: sextets have a weight of 1, double bonds have a weight of 0
    objective = [1] * l + [0] * len(bonds)

    # Solve LP problem using lpsolve
    lp = lpsolve('make_lp', m, n)               # initialize lp with constraint matrix with m rows and n columns
    lpsolve('set_verbose', lp, 2)               # reduce messages from lpsolve
    lpsolve('set_obj_fn', lp, objective)        # set objective function
    lpsolve('set_maxim', lp)                    # set solver to maximize objective
    lpsolve('set_mat', lp, a)                   # set left hand side to constraint matrix
    lpsolve('set_rh_vec', lp, [1] * m)          # set right hand side to 1 for all constraints
    lpsolve('set_constr_type', lp, ['='] * m)   # set all constraints as equality constraints
    lpsolve('set_binary', lp, [True] * n)       # set all variables to be binary

    # Constrain values of exocyclic bonds, since we don't want to modify them
    for i in range(l, n):
        if exo[i - l] is not None:
            # NOTE: lpsolve indexes from 1, so the variable we're changing should be i + 1
            lpsolve('set_bounds', lp, i + 1, exo[i - l], exo[i - l])

    # Add constraints to problem if provided
    if constraints is not None:
        for constraint in constraints:
            try:
                lpsolve('add_constraint', lp, constraint[0], '<=', constraint[1])
            except:
                logging.error('Unable to add constraint: {0} <= {1}'.format(constraint[0], constraint[1]))
                logging.error('Cannot complete Clar optimization for {0}.'.format(str(mol)))
                logging.error(mol.toAdjacencyList())
                raise

    status = lpsolve('solve', lp)
    objVal, solution = lpsolve('get_solution', lp)[0:2]
    lpsolve('delete_lp', lp)  # Delete the LP problem to clear up memory

    # Reset signal handling since lpsolve changed it
    try:
        signal.signal(signal.SIGINT, sig)
    except ValueError:
        # This is not being run in the main thread, so we cannot reset signal
        pass

    # Check that optimization was successful
    if status != 0:
        raise ILPSolutionError('Optimization could not find a valid solution.')

    # Check that we the result contains at least one aromatic sextet
    if objVal == 0:
        return []

    # Check that the solution contains the maximum number of sextets possible
    if maxNum is None:
        maxNum = objVal  # This is the first solution, so the result should be an upper limit
    elif objVal < maxNum:
        raise ILPSolutionError('Optimization obtained a sub-optimal solution.')

    if any([x != 1 and x != 0 for x in solution]):
        raise ILPSolutionError('Optimization obtained a non-integer solution.')

    # Generate constraints based on the solution obtained
    y = solution[0:l]
    new_a = y + [0] * len(bonds)
    new_b = sum(y) - 1
    if constraints is not None:
        constraints.append((new_a, new_b))
    else:
        constraints = [(new_a, new_b)]

    # Run optimization with additional constraints
    try:
        innerSolutions = _clar_optimization(mol, constraints=constraints, maxNum=maxNum)
    except ILPSolutionError:
        innerSolutions = []

    return innerSolutions + [(molecule, aromaticRings, bonds, solution)]


def _clar_transformation(mol, aromaticRing):
    """
    Performs Clar transformation for given ring in a molecule, ie. conversion to aromatic sextet.

    Args:
        mol             a :class:`Molecule` object
        aromaticRing    a list of :class:`Atom` objects corresponding to an aromatic ring in mol

    This function directly modifies the input molecule and does not return anything.
    """
    cython.declare(bondList=list, i=cython.int, atom1=Atom, atom2=Atom, bond=Bond)

    bondList = []

    for i, atom1 in enumerate(aromaticRing):
        for atom2 in aromaticRing[i + 1:]:
            if mol.hasBond(atom1, atom2):
                bondList.append(mol.getBond(atom1, atom2))

    for bond in bondList:
        bond.order = 1.5
