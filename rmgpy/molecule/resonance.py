#!/usr/bin/env python
# encoding: utf-8

################################################################################
#
#   RMG - Reaction Mechanism Generator
#
#   Copyright (c) 2002-2017 Prof. William H. Green (whgreen@mit.edu), 
#   Prof. Richard H. West (r.west@neu.edu) and the RMG Team (rmg_dev@mit.edu)
#
#   Permission is hereby granted, free of charge, to any person obtaining a
#   copy of this software and associated documentation files (the 'Software'),
#   to deal in the Software without restriction, including without limitation
#   the rights to use, copy, modify, merge, publish, distribute, sublicense,
#   and/or sell copies of the Software, and to permit persons to whom the
#   Software is furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in
#   all copies or substantial portions of the Software.
#
#   THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#   DEALINGS IN THE SOFTWARE.
#
################################################################################

"""
This module contains methods for generation of resonance structures of molecules.

The main function to generate all relevant resonance structures for a given
Molecule object is ``generateResonanceStructures``. It calls the necessary
functions for generating each type of resonance structure.

Currently supported resonance types:
- All species:
    - ``generateAdjacentResonanceStructures``: single radical shift with double or triple bond
    - ``generateLonePairRadicalResonanceStructures``: single radical shift with lone pair
    - ``generateN5dd_N5tsResonanceStructures``: shift between nitrogen with two double bonds and single + triple bond
- Aromatic species only:
    - ``generateAromaticResonanceStructures``: fully delocalized structure, where all aromatic rings have benzene bonds
    - ``generateKekuleStructure``: generate a single Kekule structure for an aromatic compound (single/double bond form)
    - ``generateOppositeKekuleStructure``: for monocyclic aromatic species, rotate the double bond assignment
    - ``generateClarStructures``: generate all structures with the maximum number of pi-sextet assignments
"""

import cython
import logging
import itertools

from .graph import Vertex, Edge, Graph, getVertexConnectivityValue
from .molecule import Atom, Bond, Molecule
from .kekulize import kekulize
import rmgpy.molecule.pathfinder as pathfinder
from rmgpy.exceptions import ILPSolutionError, KekulizationError, AtomTypeError

def populateResonanceAlgorithms(features=None):
    """
    Generate list of resonance structure algorithms relevant to the current molecule.

    Takes a dictionary of features generated by analyzeMolecule().
    Returns a list of resonance algorithms.
    """
    cython.declare(methodList=list)
    methodList = []

    if features is None:
        methodList = [
            generateAdjacentResonanceStructures,
        ]
    else:
        # If the molecule is aromatic, then radical resonance has already been considered
        # If the molecule was falsely identified as aromatic, then isArylRadical will still accurately capture
        # cases where the radical is in an orbital that is orthogonal to the pi orbitals.
        if features['isRadical']:
            methodList.append(generateAdjacentResonanceStructures)

    return methodList

def analyzeMolecule(mol):
    """
    Identify key features of molecule important for resonance structure generation.

    Returns a dictionary of features.
    """
    cython.declare(features=dict)

    features = {'isRadical': mol.isRadical(),
                }

    return features

def generateResonanceStructures(mol, clarStructures=True, keepIsomorphic=False):
    """
    Generate and return all of the resonance structures for the input molecule.

    Most of the complexity of this method goes into handling aromatic species, particularly to generate an accurate
    set of resonance structures that is consistent regardless of the input structure. The following considerations
    are made:

    1. False positives from RDKit aromaticity detection can occur if a molecule has exocyclic double bonds
    2. False negatives from RDKit aromaticity detection can occur if a radical is delocalized into an aromatic ring
    3. sp2 hybridized radicals in the plane of an aromatic ring do not participate in hyperconjugation
    4. Non-aromatic resonance structures of PAHs are not important resonance contributors (assumption)

    Aromatic species are broken into the following categories for resonance treatment:

    - Radical polycyclic aromatic species: Kekule structures are generated in order to generate adjacent resonance
    structures. The resulting structures are then used for Clar structure generation. After all three steps, any
    non-aromatic structures are removed, under the assumption that they are not important resonance contributors.
    - Radical monocyclic aromatic species: Kekule structures are generated along with adjacent resonance structures.
    All are kept regardless of aromaticity because the radical is more likely to delocalize into the ring.
    - Stable polycyclic aromatic species: Clar structures are generated
    - Stable monocyclic aromatic species: Kekule structures are generated
    """
    cython.declare(molList=list, newMolList=list, features=dict, methodList=list)

    molList = [mol]

    # Analyze molecule
    features = analyzeMolecule(mol)

    # Generate remaining resonance structures
    methodList = populateResonanceAlgorithms(features)
    _generateResonanceStructures(molList, methodList, keepIsomorphic)

    return molList

def _generateResonanceStructures(molList, methodList, keepIsomorphic=False, copy=False):
    """
    Iteratively generate all resonance structures for a list of starting molecules using the specified methods.

    Args:
        molList             starting list of molecules
        methodList          list of resonance structure algorithms
        keepIsomorphic      if False, removes any structures that give isIsomorphic=True (default)
                            if True, only remove structures that give isIdentical=True
        copy                if False, append new resonance structures to input list (default)
                            if True, make a new list with all of the resonance structures
    """
    cython.declare(index=cython.int, molecule=Molecule, newMolList=list, newMol=Molecule, mol=Molecule)

    if copy:
        # Make a copy of the list so we don't modify the input list
        molList = molList[:]

    # Iterate over resonance isomers
    index = 0
    while index < len(molList):
        molecule = molList[index]
        newMolList = []

        for method in methodList:
            newMolList.extend(method(molecule))

        for newMol in newMolList:
            # Append to isomer list if unique
            for mol in molList:
                if not keepIsomorphic and mol.isIsomorphic(newMol):
                    break
                elif keepIsomorphic and mol.isIdentical(newMol):
                    break
            else:
                molList.append(newMol)

        # Move to next resonance isomer
        index += 1

    return molList

def generateAdjacentResonanceStructures(mol):
    """
    Generate all of the resonance structures formed by one allyl radical shift.

    Biradicals on a single atom are not supported.
    """
    cython.declare(isomers=list, paths=list, index=cython.int, isomer=Molecule)
    cython.declare(atom=Atom, atom1=Atom, atom2=Atom, atom3=Atom, bond12=Bond, bond23=Bond)
    cython.declare(v1=Vertex, v2=Vertex)
    
    isomers = []

    # Radicals
    if mol.isRadical():
        # Iterate over radicals in structure
        for atom in mol.vertices:
            paths = pathfinder.findAllDelocalizationPaths(atom)
            for atom1, atom2, atom3, bond12, bond23 in paths:
                # Adjust to (potentially) new resonance isomer
                atom1.decrementRadical()
                atom3.incrementRadical()
                bond12.incrementOrder()
                bond23.decrementOrder()
                # Make a copy of isomer
                isomer = mol.copy(deep=True)
                # Also copy the connectivity values, since they are the same
                # for all resonance forms
                for index in range(len(mol.vertices)):
                    v1 = mol.vertices[index]
                    v2 = isomer.vertices[index]
                    v2.connectivity1 = v1.connectivity1
                    v2.connectivity2 = v1.connectivity2
                    v2.connectivity3 = v1.connectivity3
                    v2.sortingLabel = v1.sortingLabel
                # Restore current isomer
                atom1.incrementRadical()
                atom3.decrementRadical()
                bond12.decrementOrder()
                bond23.incrementOrder()
                # Append to isomer list if unique
                isomer.updateAtomTypes(logSpecies=False)
                isomers.append(isomer)

    return isomers

